# Implement & Understand Lambda Calculus with Javascript

## 简介

λ 演算法是某某某在某一年提出来的图灵完备的，用来抽象描述计算方法的模型。

这个人具体是谁我忘记了，但是这个人应该和阿兰图灵有某种巧妙的联系，要么是后者的老师，要么是后者的学生。

λ 演算法是图灵完备的，代表着它可以完整的实现图灵机所能实现的所有功能。即给定它所需要的所有条件后，它可以解决任意的可计算问题。它可以和图灵机相互转换，进行任意计算的图灵机都可以转换成 λ 演算法的形态，而后者也可以随时转化成等价的图灵机。

可以说，λ 演算法就是一种完全不同的看待 **计算** 的一种方式，它是很多函数式编程的基础，通过 λ 表达式和闭包函数影响了许许多多的现代编程语言，例如 `LISP`，`Haskell` 都是受其启发而生，在 _Javascript_ 中也有很强烈的存在感。

## 语法

λ 演算法本身的语法十分简洁，但其实不甚明了，逻辑复杂时会变得极其繁复。主要由以下规则定义:

- 所有的变量的类型都是函数
- 函数由输入和输出组成
- 因为所有类型都是函数，所有他们之间只有调用这一种关系，也就是将一个变量作为参数传入另一个变量的函数中，并返回后者的输出
- 函数没有内部状态，相同的输入一定会得到相同输出。

语法大致规则如下

- 函数由参数和函数体组成，参数以 `λ + 参数名` 的方式表示，而函数体直接以表达式表示。
- 参数声明相互之间，参数和函数体之间都以 `.` 相连。
- 函数会试图用自己的参数来同函数体后面的表达式进行模式匹配，匹配成功则将使用匹配的结果作为参数调用自己，并返回返回值。
- 可以用括号将一段合法的表达式括起来，表示这是一个整体。

例如 λ 演算法中的 `λx.λy.x` （有些地方也会写作 `λxy.x`, 这两种写法应该都可以） 等价于 _Javascript_ 中的：

```Javascript
// Javascript
(x, y) => x;
```

也可以看一下下面这个例子：

`λx.x λy.λz.yz` 可以认为同 `λy.λz.yz` 等价。后面的 Lambda 函数 `λy.λz.yz` 整体被前面的函数 `λx.x` 的参数 `x` 匹配到，并被作为参数调用了 `λx.x` 这个函数，自身被作为输出返回了出来。由于 `λy.λz.yz` 这个函数的参数并没有成功匹配后面的内容（后面也没有内容了），因此其作为函数本身保留了下来。
用 _Javascript_ 来表示一下就是：

```javascript
const fn1 = (x) => x;
const fn2 = (y, z) => yz;

const assert_eq = (e1, e2) => {
  if (e1 !== e2) throw new Error("Test failed!");
};

assert_eq(fn1(fn2), fn2); // pass
```

注意这里 `fn2` 输出的 `yz` 并不等于 `y * z ` 或者 ` ...[y,z]` ，也不同于 Javascript 中的 `y.call(y,z)` 这样的关系。

相反，`yz` 表示的是一种 `y` 和 `z` 一起等待被匹配的一种状态, 有点类似正则表达式中的相邻元素的关系。

如果 `yz` 前面有一个接受两个参数的函数，那么二者就会分别作为这两个参数传入前面的方法中；而如果编译到这里只剩下 `yz` ， 并且 `y` 自身恰好是一个只接受一个参数的函数，那么 `z` 就会作为参数传入 `y` 并返回 `y(z)` 的结果，即 `y(z)` 。

## 基本逻辑单元及其 Javascript 函数的表示法

λ 演算法中所有的变量都是函数，但其又是图灵完备的，也就是说所有的逻辑变量都是以函数的形式存在于 λ 演算法中。每种逻辑单元实际上都应该有不止一种函数表示方法，但是有一些非常基本的逻辑符号是存在约定俗称的定义的，一旦约定了这些基本的逻辑符号，其他的元素就可以被推导出来。

---

### 布尔值

`true` 和 `false` 表示的是两种截然不同的状态。
任意能够表示两种不同状态的函数都能用来表示布尔值，在 λ 演算法中，约定了 `λx.λy.x` 来表示 `true`，表示在给定的两个输入中返回第一个；用 `λx.λy.y` 来表示 `false`，表示在两个输入中返回第二个。
我们并不关系被输入的东西究竟是什么，我们在意的是从中挑选一个的这个逻辑。

> true
> : `λx.λy.x`

> false
> : `λx.λy.y`

用 _Javascript_ 来表示就是

```javascript
// λx.λy.x
const True = (x, y) => x;
// λx.λy.y
const False = (x, y) => y;
```

---

### 非

与，或，非中，我们可以先从最简单的 _非_ 来考虑，它接受一个布尔值，并且输出另一个布尔值。

你可能首先想到这样一种实现方法，就是让我们判断输入的布尔值是不是 `true` 。如果是的话就返回 `false` ，否则返回 `true`。 就如同下面这段代码：

<i id="anchor-1"></i>

```typescript
type Bool = True | False;
const __Not( bool: Bool ) = bool === True ? False : True;
```

如果你使用的是 typescript，你很快就会发现问题。 `True` ， `False` 以及 `bool` 都是函数，它们之间的比较很难说有什么意义。事实上我们之前也曾经提到过，λ 演算法中函数之间只有调用这一种关系，并没有其他任何可用的操作，因此我们必须另寻他法。

我们之前已经定义了布尔值是这样的一类函数，它接受两个不同的输入，返回其中一个。并且我们显式的将 `True`
命名为返回第一个参数的函数，这是不是很像[刚才的三元运算符呢](#anchor-1)？

所以，在编程语言中很常见的控制流语句： `boolean ? expression1 : expression2`

完全等价于下面这段 λ 演算法的 _Javascript_ 形式：

```javascript
const ternary = (bool, expression1, expression2) =>
  bool(expression1, expression2);
```

等价于 λ 演算法的语法中的： `λb.(b(expression1 expression2））` 。

上面三种语句中，编程语言中控制流的分支一般都不仅支持表达式（expression），同时还支持语句（statement），但是下面两个， λ 演算法及其 _Javascript_ 形式仅仅支持**表达式**，并不支持**语句**。因为表达式是具有返回值的，而语句并没有返回值。λ 演算法中的函数没有可供**语句**来改变的内部状态，它只能通过函数间传递表达式的返回值来传递信息（类似于 _Javascript_ 中的单表达式的 IIFE ）。这便是 λ 演算法和图灵机这种通过过程和状态来进行编码的计算模式最大的不同。同时，λ 演算法中没有状态或者说内存的概念，一切计算中可能出现的过程和状态的信息相当于都储存在了它的最初始的表达式中，可以由最初的表达式推演（化简），这也导致了对于相同的问题，描述 λ 演算法的算法要远比其他的图灵完备的计算机繁琐得多。

回归正题，我们可以使用这段控制流语句来改写[上面这段代码](#anchor-1)

```javascript
const Not = (bool) => bool(False, True);

Not(True); // False
```

当 bool 为 True 函数时，会选取 `(False, True)` 二者中的第一个也就是 False，反之会选择 True。

翻译成 λ 演算法的语法

> Not
> : `λb.bFalseTrue`

或者写成展开的形式：

> Not
> : `λb.b λx.λy.y λx.λy.x`

---

举一反三

其余逻辑运算符号的控制流写法：

```javascript
const __And = (bool1, bool2) => (bool1 ? bool2 : False);
const __Or = (bool1, bool2) => (bool1 ? True : bool2);
const __Equal = (bool1, bool2) => (bool1 ? bool2 : Not(Bool2));
const __Xor = (bool1, bool2) => (bool1 ? Not(bool2) : bool2);
```

转换成 λ 演算法的 _Javascript_ 形式：

```javascript
const And = (bool1, bool2) => bool1(bool2, False);
const Or = (bool1, bool2) => bool1(True, bool2);
const Equal = (bool1, bool2) => bool1(bool2, Not(Bool2));
const Xor = (bool1, bool2) => bool1(Not(bool2), bool2);
```

改写成 λ 演算法语法：

> And
> : `λa.λb.aba`

> Or
> : `λa.λb.aab`

> Equal
> : `λa.λb.ab(Not b)`

> Xor
> : `λa.λb.a(Not b)b`
